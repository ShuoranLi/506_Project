---
title: "Monte Carlo Simulation of Stock Portfolio in R, Matlab, and Python"
author: "Feichen Shen, Israel Diego, Shuoran Li"
date: "`r format.Date(Sys.Date(), '%B %d, %Y')`"
output: 
  html_document:
    theme: journal
    highlight: pygments
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(ggplot2)
```

## Monte Carlo Introduction

The purpose of this tutorial is to demonstrate Monte Carlo Simulation in Matlab, R, and Python. We conduct our Monte Carlo study in the context of simulating daily returns 
for an investment portfolio.

For simplicity we will only consider three assets: Apple, Google, and Facebook. 
We will assume an Initial Investment of $100,000 and allocate our money evenly 
between the three stocks. In this case the portfolio weights $w_i = 1/3$ for 
$i = 1,2,3$. 

Next, we assume that daily returns are distributed Multivariate Normal with mean 
vector $\mu$ and covariance matrix $\Sigma$. In other words, 
$$R_t \sim MVN(\mu, \Sigma)$$
We will use the Cholesky Factorization in order to find Lower Triangular Matrix 
$L$ such that $LL' = \Sigma$. Then our returns can be generated by 
$$ R = \mu + LZ $$ where $$Z \sim N(0,I)$$.

The returns will be simulated over a 30-day period, where our 30-day returns
can be formulated as, $$R_{30} = \prod_{i=1}^{30} (1+R_i)$$

Thus our portfolio returns for each Monte Carlo trial $m$ become the inner 
product between the 30-day returns and our vector of portfolio weights $w$, 
$$P_m = w \cdot R_{30} $$.

## Dataset Summary

We use adjusted-close stock prices for Apple, Google, and Facebook from November 14th, 2017 - November 14th, 2018. Historical stock price data can be found on Yahoo 
Finance for these companies. Also [here](https://raw.githubusercontent.com/ShuoranLi/506_Project/master/Group21_ProjectData.csv) is the link to the data set for this
tutorial.

## {.tabset}

### R
Firstly, we need to load the data
```{r R_version_c1, warning=FALSE, message=FALSE}
stock_Data = fread('./Group21_ProjectData.csv')
```
The first ten rows look like :
```{r R_version_c2, warning=FALSE, message=FALSE}
stock_Data[1:10, ]
```
Then we extract the stock price and set initial values for Monte-Carlo parameters.
```{r R_version_c3, warning=FALSE, message=FALSE}
stock_Price = as.matrix( stock_Data[ , 2:4] )

mc_rep = 1000 # Number of Monte Carlo Simulations
training_days = 30 
```
Get the returns by stock price and set the investment weights
```{r R_version_c4, warning=FALSE, message=FALSE}
# This function returns the first differences of a t x q matrix of data
returns = function(Y){
  len = nrow(Y)
  yDif = Y[2:len, ] / Y[1:len-1, ] - 1
}

# Get the Stock Returns
stock_Returns = returns(stock_Price)

# Suppose we invest our money evenly among all three assets 
# We use today's Price 11/14/2018 to find the number of shares each stock 
# that we buy
portfolio_Weights = t(as.matrix(rep(1/ncol(stock_Returns), ncol(stock_Returns))))
```
Calculate the Covariance matrix and Mean value of Stock Returns
```{r R_version_c5, warning=FALSE, message=FALSE}
# Get the Variance Covariance Matrix of Stock Returns
coVarMat = cov(stock_Returns)
miu = colMeans(stock_Returns)
# Extend the vector to a matrix
Miu = matrix(rep(miu, training_days), nrow = 3)
```
Use Monte-Carlo to simulate the 30-day Portfolio Returns
```{r R_version_c6, warning=FALSE, message=FALSE}
# Initializing simulated 30 day portfolio returns
portfolio_Returns_30_m = matrix(0, training_days, mc_rep)

set.seed(200)
for (i in 1:mc_rep) {
  Z = matrix ( rnorm( dim(stock_Returns)[2] * training_days ), ncol = training_days )
  # Lower Triangular Matrix from our Choleski Factorization
  L = t( chol(coVarMat) )
  # Calculate stock returns for each day
  daily_Returns = Miu + L %*% Z  
  # Calculate portfolio returns for 30 days
  portfolio_Returns_30 = cumprod( portfolio_Weights %*% daily_Returns + 1 )
  # Add it to the monte-carlo matrix
  portfolio_Returns_30_m[,i] = portfolio_Returns_30;
}
```
Visualising the result ( Simulated Portfolio Returns in 30 days)
```{r R_version_c7, warning=FALSE, message=FALSE}
# Visualising result
x_axis = rep(1:training_days, mc_rep)
y_axis = as.vector(portfolio_Returns_30_m-1)
plot_data = data.frame(x_axis, y_axis)
ggplot(data = plot_data, aes(x = x_axis, y = y_axis)) + geom_path(aes(col = 'red'), size = 0.1) +
  xlab('Days') + ylab('Portfolio Returns') + 
  ggtitle('Simulated Portfolio Returns in 30 days')
```

Get some useful statistics through the results we get
```{r R_version_c8, warning=FALSE, message=FALSE}
# Porfolio Returns statistics on the 30th day.
Avg_Portfolio_Returns = mean(portfolio_Returns_30_m[30,]-1)
SD_Portfolio_Returns = sd(portfolio_Returns_30_m[30,]-1)
Median_Portfolio_Returns = median(portfolio_Returns_30_m[30,]-1)
print(c(Avg_Portfolio_Returns,SD_Portfolio_Returns,Median_Portfolio_Returns))
# Construct a 95% Confidential Interval for average returns
Avg_CI = quantile(portfolio_Returns_30_m[30,]-1, c(0.025, 0.975))
print(Avg_CI)
```
### Matlab

(tab content)

### Python

(tab content)

## Results
For our particular example, the portfolio returns averaged over all monte carlo
trials had an average close to 0. The reason the average is close to 0 is 
because Apple, Facebook, and Google have average returns close to 0 over the past year. 
Therefore, our simulated returns essentially had no drift. Also, assuming a 
normal distribution of the returns would not work well in practice since 
stock returns are typically fat-tailed and not normally distributed. However, based on our 
Monte Carlo Study, we do not suggest investing in this portfolio based on the 
low expected portfolio returns. 